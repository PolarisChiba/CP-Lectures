---
tags: 2022 HWTC
---

# 樹狀樹組 BIT (Binary Indexed Tree)

> A：線段樹好難寫唷，有沒有比較好的方法呢？
> B：線段數不難寫啊(X)

## 概述

考慮以下問題：
給定一個長度為$n\leq 10^5$的數列$a_1, a_2,\cdots , a_n$，有$q \leq 10^5$個操作，分別為以下兩種：
1. 給定$L, R$，詢問$a_L + a_{L+1} + \cdots + a_{R}$的值
2. 給定$i, x$，將$a_i$的值更新成$a_i + x$

---

我們剛剛已經學會了，可以使用線段樹來有效解決這樣的問題。
不過接下來，我們會介紹另外一個「方便」的資料結構$BIT$。
$BIT$能夠快速的查詢前綴和、並且支援單點修改。

### lowbit

lowbit的定義為：一個數字寫成二進位時，最低位的$1$所對應的值。
舉例來說：

$$
lowbit(10) = lowbit(1010_2) = 10_2 = 2 \\
lowbit(17) = lowbit(10001_2) = 1_2 = 1
$$

另外，在電腦中存取數字的方式是使用$2$補數，也就是說對於一個 $4$ $bit$ 的整數：

$$
-6 = -0110_2 = 1001_2 + 1_2 = 1010_2 \\
-7 = -0111_2 = 1000_2 + 1_2 = 1001_2 \\
-1 = -0001_2 = 1110_2 + 1_2 = 1111_2 \\
$$

同時可以發現：

$$
-6 + 6 = 1010_2 + 0110_2 = 10000_2 = 0 \\
-7 + 7 = 1001_2 + 0111_2 = 10000_2 = 0 \\
-1 + 1 = 1111_2 + 0001_2 = 10000_2 = 0
$$

因為是$4$ $bit$ 的整數，因此$10000_2$會被視為$0$。
經過觀察後可以發現：

$$
lowbit(x) = (x \ \& (-x))
$$

舉例來說：

$$
lowbit(6) = (6 \& -6) = (0110_2 \& 1010_2) = (0010_2) = 2 \\
lowbit(7) = (7 \& -7) = (0111_2 \& 1001_2) = (0001_2) = 1 \\
lowbit(1) = (1 \& -1) = (0001_2 \& 1111_2) = (0001_2) = 1
$$

### BIT 陣列

有了$lowbit$後，我們定義以下數列，$\forall i = 1, 2, \cdots n$
$$
Bit_i = a_i + a_{i - 1} + a_{i - 2} + \cdots + a_{i-lowbit(i) + 1}
$$

那麼，可以發現：

$$
\begin{align}
sum(1, i) &= a_i + a_{i-1} + \cdots + a_1 \\
&= (a_i + a_{i-1}+\cdots + a_{i - lowbit(i)+1}) + (a_{i - lowbit(i)} + \cdots + a_1)  \\
&= Bit_i + sum(1, i - lowbit(i))
\end{align}
$$

因此

$$
sum(1, i) =
\begin{cases}
0 & i = 0 \\
Bit_i + sum(1, i - lowbit(i)) & 1 \leq i \leq n
\end{cases}
$$

---

另一方面，對於一個$i$，$1\leq i\leq n$，在$Bit$陣列中，需要用到$a_i$的有那些呢？

首先可以知道，$\forall k < i$，$Bit_k$不會用到$a_i$。
接著可以知道，$Bit_i$會需要用到$a_i$。
然後可以知道，$Bit_{i+lowbit(i)}$會用到$a_i$。

( 因為$i \in [i + lowbit(i) - lowbit(i + lowbit(i)), i + lowbit(i)]$）

還有可以知道，$\forall k \in (i, i + lowbit(i))$，$Bit_k$不會用到$a_i$。

因此，若我們用$B$來代表會用到$a_i$的那些$Bit$陣列中的編號的話，則：

$$
B_k = 
\begin{cases}
i & k = 0 \\
B_{k - 1} + lowbit(B_{k - 1}) & else
\end{cases}
$$

一直到$B_k > n$為止。

如此一來，若我們修改$a_i$的值的時候，我們就知道會動到那些$Bit$陣列中的值，從而可以好好的維護$Bit$陣列。

> P.S.如果看不太懂的話可以先跳過，對各位比較重要的是下面的程式碼部分

### 程式碼

```cpp=
int n;
int bit[100000 + 9];
int lowbit(int i) {
    return (i & (-i));
}
int query(int i) {
    if (i == 0) return 0;
    return bit[i] + query(i - lowbit(i));
}
void modify(int i, int x) {
    if (i > n) return;
    bit[i] += x;
    modify(i + lowbit(i), x);
}
```

不過，相較於使用遞迴的寫法，更常見的是以下這種迭代的寫法。

```cpp=
int n;
int bit[100000 + 9];
void modify(int i, int x) {
    while (i <= n) {
        bit[i] += x;
        i += i & -i;
    }
}
int query(int i) {
    int res = 0;
    while (i) {
        res += bit[i];
        i -= i & -i;
    }
    return res;
}
```

$BIT$支援單點修改、計算前綴和，不過任意區間的和也可以透過以下的方式得到：

$$
sum(l, r) = sum(1, r) - sum(1, l - 1)
$$

所以就只需要呼叫$query(r) - query(l - 1)$就能夠得到$[l, r]$區間的和了。

### 複雜度

$modify$時是不斷的扣掉$lowbit$、$query$時是不斷加上$lowbit$。
根據$lowbit$的性質，執行的次數不會超過$n$的二進位表示法的長度。
也就是說，兩個操作的複雜度都是$O(log(n))$。
因此，在單點修改、區間查值的情況下，$BIT$能夠在少許的程式碼下，辦到與線段樹同樣的事情。

## 例題演練

### 逆序數對 

給定一個長度為$n \leq 10^5$的數列$a_1, a_2, \cdots, a_n$，請問有多少組逆序數對？
保證$1\leq a_i \leq n, \ \forall i = 1, 2, \cdots, n$。 
（逆序數對為$pair(i, j）,\ i < j$，使的$a_i > a_j$ )

---

在第一天的課程中似乎講過使用$mergesort$來解的方法。
但接下來我們會講解如何以$BIT$來解這一題。

舉例來說：

$a = {3, 1, 2, 4, 1, 4}$

從小的數字，一個一個加進下方的表格中。
填入$1$的原因是代表那個位置被一個數字所佔據了。

|     |     |     |     |     |     |
| --- |:---:| --- |:---:| --- | --- |

逆數數對：$0$

---

$a = {3, 1, 2, 4, 1, 4}$

|     | ++1++ |     |     |     |     |
| --- |:-----:| --- |:---:| --- | --- |

逆數數對：$0$

---

$a = {3, 1, 2, 4, 1, 4}$

|     |  1  |     |     | ++1++ |     |
| --- |:---:| --- |:---:|:-----:| --- |

逆數數對：$0$

---

$a = {3, 1, 2, 4, 1, 4}$

|     |  1  | ++1++ |     | 1   |     |
| --- |:---:|:-----:|:---:| --- | --- |

可以發現，此時加入的$2$後面有一個數字$1$比它小，因此將逆序數對數量加$1$。
逆數數對：$1$

---

$a = {3, 1, 2, 4, 1, 4}$

| ++1++ |  1  | 1   |     | 1   |     |
|:-----:|:---:| --- |:---:| --- | --- |

可以發現，此時加入的$3$後面有三個數字比它小，因此將逆序數對數量加$3$。
逆數數對：$4$

---

$a = {3, 1, 2, 4, 1, 4}$

| 1   |  1  | 1   | ++1++ | 1   |     |
| --- |:---:| --- |:-----:| --- | --- |

可以發現，此時加入的$4$後面有一個數字比它小，因此將逆序數對數量加$1$。
逆數數對：$5$

---

$a = {3, 1, 2, 4, 1, 4}$

| 1   |  1  | 1   |  1  | 1   | ++1++ |
| --- |:---:| --- |:---:| --- |:-----:|

可以發現，此時加入的$4$後面有沒有數字比它小，因此將逆序數對數量不變。
逆數數對：$5$

至此我們就完成了。

---

```cpp=
#include <bits/stdc++.h>
using namespace std;

int n;
int bit[100000 + 9];
void modify(int i, int x) {
    while (i <= n) {
        bit[i] += x;
        i += i & -i;
    }
}
int query(int i) {
    int res = 0;
    while (i) {
        res += bit[i];
        i -= i & -i;
    }
    return res;
}

int main() {
    cin >> n;
    vector<pair<int, int>> v(n);
    for (int i = 0; i < n; ++ i) {
        cin >> v[i].first;
        v[i].second = i + 1; // BIT是從 1 ~ n 的
    }
    sort(v.begin(), v.end());
    
    int ans = 0;
    for (auto i : v) {
        // 計算這個位置後面已經有多少個位置已經被填上了
        // 在這個位置後面、且被填上的話，代表那些格子的數字比i.first還要小
        // 注意到，相同的數字會由左到右處理，所以不會被算到
        ans += query(n) - query(i.second); 
        // 將這個位置也設為 1
        modify(i.second, 1);
    }
    cout << ans << "\n";
}
```

值得一提的是，除了這種考慮「位置」的做法以外，還有另外一種考慮「值域」的作法，如果有興趣的人可以想想看。

## 區間最大值？

我們在前面說到，$BIT$可以用來計算任意區間的和，那麼任意區間的最大值呢？

之所以$BIT$可以用來計算任意區間的和，是因為區間和有以下的性質：

$$
sum(l, r) = sum(1, r) - sum(1, l - 1)
$$

區間和可以由兩個前綴和相減得到，然而區間最大值卻沒有這樣的性質。
因此$BIT$沒有辦法「直接」應用在求區間最大值的題目上。
更進一步來說，$BIT$只能夠處理與「前綴」相關的資訊。

但其實還是有辦法的，但我們不會在這裡講到。
如果有興趣的人，就請自行查閱吧。

## 二維BIT

到目前為止，我們都只討論了一維的情況。
不過實際上，$BIT$也可以用來處理二維、甚至更高維的陣列的單點修改、區間和。
這裡不會細講，先附上程式碼，有興趣的人可以看看。

```cpp=
int n, m; // 陣列的大小
int bit[1000 + 9][1000 + 9];
void modify(int i, int j, int v) {
    while (i <= n) {
        int res = j;
        whlie (j <= m) {
            bit[i][j] += v;
            j += j & -j;
        }
        j = res;
        i += i & -i;
    }
}
int query(int i, int j) {
    int res = 0;
    while (i) {
        int res = j;
        while (j) {
            res += bit[i][j];
            j -= j & -j;
        }
        j = res;
        i -= i & -i;
    }
    return res;
}
```

## 總結

$BIT$能辦到的事情，大部分線段樹都可以辦到。
然而許多能用線段樹解開的題目，卻是無法使用$BIT$解開的。
但是在資訊競賽中，$BIT$依然遠近馳名，究其原因，是因為$BIT$相對於線段樹來說，實在是太好寫了。
